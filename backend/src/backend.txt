E:\Projekte\Coding\github\Design-System-Docs\backend\src\index.ts 
// File: /src/index.ts (or .js)
export default {
  async register(/*{ strapi }*/) {
    // This runs before the bootstrap below, but after 
    // every plugin has been loaded.
  },

  async bootstrap({ strapi }) {
    const pluginStore = await strapi.store({
      type: 'plugin',
      name: 'users-permissions',
      key: 'grant',
    });

    const grantConfig = await pluginStore.get();

    // Configure GitHub OAuth
    if (!grantConfig.github) {
      grantConfig.github = {};
    }

    grantConfig.github.enabled = true;
    grantConfig.github.key = process.env.GITHUB_CLIENT_ID || 'myDefaultKey';
    grantConfig.github.secret = process.env.GITHUB_CLIENT_SECRET || 'myDefaultSecret';
    grantConfig.github.callbackUrl = 'api/auth/github/callback';
    grantConfig.github.redirectUri = 'http://localhost:1337/api/connect/github/callback';
    grantConfig.github.scope = ['repo', 'user', 'user:email'];

    await pluginStore.set({ value: grantConfig });
    strapi.log.info('> Updated GitHub provider scope + enabled in the plugin store!');
  },
}; 
E:\Projekte\Coding\github\Design-System-Docs\backend\src\admin\vite.config.example.ts 
import { mergeConfig, type UserConfig } from 'vite';

export default (config: UserConfig) => {
  // Important: always return the modified config
  return mergeConfig(config, {
    resolve: {
      alias: {
        '@': '/src',
      },
    },
  });
};
 
E:\Projekte\Coding\github\Design-System-Docs\backend\src\api\github\controllers\github.ts 
interface CreateRepoBody {
  name: string;
  description?: string;
  private?: boolean;
  auto_init?: boolean;
}

interface GitHubErrorResponse {
  message: string;
  documentation_url?: string;
}

interface GitHubSuccessResponse {
  id: number;
  name: string;
  full_name: string;
  html_url: string;
}

export default {
  async createRepo(ctx) {
    try {
      // Verify user is authenticated
      if (!ctx.state.user) {
        return ctx.unauthorized('You must be logged in');
      }

      // Get the GitHub token from request header
      const githubToken = ctx.request.header['github-token'];
      console.log('Received GitHub token:', githubToken ? 'present' : 'missing');
      console.log('User:', ctx.state.user);
      
      if (!githubToken) {
        return ctx.unauthorized('No GitHub token provided');
      }

      const response = await fetch('https://api.github.com/user/repos', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${githubToken}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(ctx.request.body as CreateRepoBody),
      });

      const data = await response.json() as GitHubErrorResponse | GitHubSuccessResponse;

      if (!response.ok) {
        return ctx.badRequest('message' in data ? data.message : 'Failed to create repository');
      }

      return { data };
    } catch (error) {
      console.error('Controller error:', error);
      return ctx.badRequest(error instanceof Error ? error.message : 'Unknown error');
    }
  },
};  
E:\Projekte\Coding\github\Design-System-Docs\backend\src\api\github\routes\github.ts 
export default {
  routes: [
    {
      method: 'POST',
      path: '/github/create-repo',
      handler: 'github.createRepo',
      config: {
        auth: {
          enabled: true,
        },
        policies: [],
        middlewares: [],
      },
    },
  ],
};  
E:\Projekte\Coding\github\Design-System-Docs\backend\src\middlewares\github-callback.ts 
interface GitHubUser {
  login: string;
  email?: string;
  id: number;
  node_id: string;
  avatar_url: string;
  name?: string;
}

interface GitHubEmail {
  email: string;
  primary: boolean;
  verified: boolean;
  visibility: string | null;
}

export default () => {
  return async (ctx, next) => {
    await next();

    // Only handle GitHub callback responses
    if (ctx.url.startsWith('/api/connect/github/callback') && ctx.status === 302) {
      try {
        // Extract access token from the redirect URL
        const redirectUrl = new URL(ctx.response.get('Location'));
        const access_token = redirectUrl.searchParams.get('access_token');

        if (!access_token) {
          console.log('No access token found in redirect URL');
          return;
        }

        // Get user data from GitHub
        const githubUserResponse = await fetch('https://api.github.com/user', {
          headers: {
            'Authorization': `Bearer ${access_token}`,
            'Accept': 'application/json',
          },
        });
        
        const githubUser = await githubUserResponse.json() as GitHubUser;

        // Get user's emails from GitHub
        const emailsResponse = await fetch('https://api.github.com/user/emails', {
          headers: {
            'Authorization': `Bearer ${access_token}`,
            'Accept': 'application/json',
          },
        });

        const emails = await emailsResponse.json() as GitHubEmail[];
        const primaryEmail = emails.find(email => email.primary)?.email;

        if (!primaryEmail) {
          console.log('No primary email found in GitHub user data');
          return;
        }

        // Find or create user
        const existingUser = await strapi.query('plugin::users-permissions.user').findOne({
          where: { email: primaryEmail },
        });

        // Get authenticated role
        const authenticatedRole = await strapi.query('plugin::users-permissions.role').findOne({
          where: { type: 'authenticated' },
        });

        const userData = {
          username: githubUser.login,
          email: primaryEmail,
          provider: 'github',
          confirmed: true,
          blocked: false,
          role: authenticatedRole.id,
        };

        let user;
        if (!existingUser) {
          user = await strapi.query('plugin::users-permissions.user').create({
            data: userData,
          });
        } else {
          user = await strapi.query('plugin::users-permissions.user').update({
            where: { id: existingUser.id },
            data: userData,
          });
        }

        // Generate JWT token
        const jwt = strapi.plugins['users-permissions'].services.jwt.issue({
          id: user.id,
        });

        // Update redirect URL with JWT
        redirectUrl.searchParams.set('jwt', jwt);
        ctx.set('Location', redirectUrl.toString());
      } catch (error) {
        console.error('GitHub callback middleware error:', error);
      }
    }
  };
};  
